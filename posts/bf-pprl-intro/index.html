<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Find duplicates in your datasets with this one weird data structure | Eulenbude
</title><link rel=stylesheet href=https://eulenbu.de/css/termeul.css><link rel=stylesheet href=https://eulenbu.de/css/custom.css><meta name=description content="Let’s consider the following scenario that is definitely not taken from any real-life events. A person is admitted to a hospital with a suspected flu. Upon closer inspection though, none of the symptoms seem to line up with known strains of influenza. Similar observations are reported by other hospitals over the following days. This prompts the doctors in charge to send swabs taken from affected patients to nearby virology laboratories."><meta name=keywords content="cybersec,privacy,pprl,security,infosec,programming,code,python,linkage,record,data,science"><meta property="og:title" content="Find duplicates in your datasets with this one weird data structure | Eulenbude"><meta property="og:description" content="Let’s consider the following scenario that is definitely not taken from any real-life events. A person is admitted to a hospital with a suspected flu. Upon closer inspection though, none of the symptoms seem to line up with known strains of influenza. Similar observations are reported by other hospitals over the following days. This prompts the doctors in charge to send swabs taken from affected patients to nearby virology laboratories."><meta property="og:url" content="https://eulenbu.de/posts/bf-pprl-intro/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Find duplicates in your datasets with this one weird data structure | Eulenbude"><meta name=twitter:description content="Let’s consider the following scenario that is definitely not taken from any real-life events. A person is admitted to a hospital with a suspected flu. Upon closer inspection though, none of the symptoms seem to line up with known strains of influenza. Similar observations are reported by other hospitals over the following days. This prompts the doctors in charge to send swabs taken from affected patients to nearby virology laboratories."><meta name=apple-mobile-web-app-title content="Find duplicates in your datasets with this one weird data structure | Eulenbude"><link rel="shortcut icon" href=https://eulenbu.de/favicon.ico><link rel=icon type=image/png sizes=96x96 href=https://eulenbu.de/favicon-96x96.png><link rel=icon type=image/svg+xml href=https://eulenbu.de/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://eulenbu.de/apple-touch-icon.png><link rel=manifest href=https://eulenbu.de/site.webmanifest></head><body><div class=bg><div class="bg-layer bg-layer-back"></div><div class="bg-layer bg-layer-front"></div><div class="bg-layer bg-layer-overlay"></div></div><div class=page><header class=page-header><nav class="nav nav-main"><ul><li class=li-no-marker><h1 class=page-logo><a href=https://eulenbu.de/>Eulenbude</a></h1></li><li><a href=https://eulenbu.de/posts>Posts</a></li><li><a href=https://eulenbu.de/termeul>Termeul</a></li></ul></nav></header><main class=page-main><div class=post><h1>Find duplicates in your datasets with this one weird data structure</h1><p class=post-date>Published on
<time datetime=$creationDateMachine>2022-10-29</time></p><blockquote><p>This post is part of a series on Bloom filter based privacy-preserving record linkage.
If you&rsquo;re new to this series, then I highly recommend you read this post first as a primer on what you&rsquo;re getting yourself into.</p><ul><li><strong><a href=https://eulenbu.de/posts/bf-pprl-intro/>Find duplicates in your datasets with this one weird data structure</a></strong></li><li><a href=https://eulenbu.de/posts/bf-pprl-attacks/>You show me your bits, I show you who you are</a></li><li><a href=https://eulenbu.de/posts/bf-popcnt/>How to count bits at the speed of light</a></li><li><a href=https://eulenbu.de/posts/bf-ncvr/>Becoming one in a million by giving up your data</a></li></ul></blockquote><p>Let&rsquo;s consider the following scenario that is definitely not taken from any real-life events.
A person is admitted to a hospital with a suspected flu.
Upon closer inspection though, none of the symptoms seem to line up with known strains of influenza.
Similar observations are reported by other hospitals over the following days.
This prompts the doctors in charge to send swabs taken from affected patients to nearby virology laboratories.</p><p>One of the hospitals receives a test result after some days, and it is worrying: a currently unknown type of virus seems to be making the rounds.
The cooperation of all airline carriers is sought to stop the uncontrolled spread of this new disease.
Customer data of the last two weeks should be queried and matched with the hospital data of infected patients.
Passengers who sat in the same plane with those who are infected should be contacted and warned.</p><p>This is the scenario that I opened my master thesis with.
And this is how I want to start a series of posts covering little details that were out of scope for my master thesis.
Because what sounds like something that can be solved with a single database query gets more complicated the deeper you look into it.
But first, let&rsquo;s assess some of the core problems in this simple introduction.</p><h2 id=these-darn-kids-and-their--privacy>These darn kids and their &mldr; privacy</h2><p>&ldquo;It would be great if there was a single code that we could use to uniquely identify a person, like a human identifier.&rdquo;
These are words that no one ever said.
In reality, this would be a privacy nightmare.
And existing identifiers that come close to this idea, like your social security number or the number on your drivers license, are out of scope for many applications.
I would get very suspicious if my airline suddenly started asking me for my insurance number.</p><p>In practice, record linkage is often performed on so-called <strong>quasi-identifiers</strong>, or QIDs for short.
Common QIDs are your first and last name, your biological gender and your birth date.
They also happen to be included in pretty much every application where data about people needs to be collected.
Cool, so we can just collect a bunch of QIDs on every person from several data sources and be done, right?</p><p>Well, no.
Because even though these QIDs don&rsquo;t say much on their own, they can become personally identifiable data when combined.
This is a desirable effect in record linkage, but you bet that every somewhat competent data protection officer will sound the alarm at this point.
There is legislation in place like the GDPR in Europe, the HIPAA in the United States, and the Data-matching Act in Australia that regulates the flow of this kind of data.
Sharing a fraction of this data can be problematic even for research purposes, that is if you&rsquo;re even allowed to do that in the first place.
So let&rsquo;s pretend that we lawyer up and we get some sort of data sharing agreement going.
This should be the end, right?</p><p>Still, no.
We still have to deal with errorenous data.
Let&rsquo;s assume the personal data of John Doe is present in two different datasets.
Misspellings of their name could be a simple typo like &ldquo;John Due&rdquo; or &ldquo;John Doé&rdquo;, or something evil like &ldquo;John Dоe&rdquo;<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> which, although unlikely, is an error that could happen due to optical character recognition for example.
Whether it&rsquo;s due to human error or a technical malfunction, these types of errors are probably more common than you think.
In record linkage, handling these type of errors has been an area of research for decades now, and it is still actively being worked on.</p><p>To summarize, there are three main problems that need solving.</p><ol><li>We cannot use universal identifiers and have to rely on QIDs instead.</li><li>We cannot assume that we&rsquo;ll be given QIDs due to privacy concerns.</li><li>We have to account for typographic and technical errors in data.</li></ol><p>A possible solution to this problem was discovered by researchers in the early 2010s, using a nifty data structure that was first described in the 1970s.</p><h2 id=a-blooming-prospect>A blooming prospect</h2><p>Burton Howard Bloom conceived the idea of a probabilistic data structure to test if an element is in a set with some false positive probability, which became known as a <strong>Bloom filter</strong>.
To put it bluntly, a Bloom filter behaves a bit like a dictionary of things.
You can put things into a Bloom filter for the purpose of looking them up at a later point in time.
When you ask the Bloom filter whether it contains a thing or not, you will get one of two answers:</p><ul><li>The thing <strong>may have been inserted</strong> into the Bloom filter.</li><li>The thing <strong>has definitely not been inserted</strong> into the Bloom filter.</li></ul><p>This means that the &ldquo;positive&rdquo; response has a certain probability of being false.
But what good is a dictionary that doesn&rsquo;t know for sure whether it contains something or not?
Bloom filters are ridiculously efficient when it comes to the amount of memory they use.
They are often used in software where lookup operations happen very frequently and are time-critical.</p><p>An example of Bloom filters in action are content delivery networks (CDNs)<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.
CDNs consist of servers spanning the entire globe that offer large amounts of content to clients.
This content needs to be kept in sync between servers in a CDN.
Suppose server <em>A</em> has files that server <em>B</em> does not have, then server <em>B</em> can use Bloom filters to inform server <em>A</em> about missing files.
Server <em>B</em> populates a Bloom filter with all files it owns (or their signatures, more realistically) and sends it to server <em>A</em>.
Now server <em>A</em> can traverse its own files and look them up in the Bloom filter that server <em>B</em> sent.
The Bloom filter guarantees that missing files will definitely be identified as such, which server <em>A</em> can then send to server <em>B</em>.
And while there may be some false positives, this is still significantly faster than a thorough file-by-file comparison.</p><p>With this short dive into Bloom filters and their applications out of the way, let&rsquo;s have a look at their inner workings.
Bloom filters are bit arrays of size <em>m</em> which are all initially set to <em>zero</em>.
Every item that is inserted into the Bloom filter is run through <em>k</em> hash functions which, consequentially, yield <em>k</em> hash values.
These hash values point to indices in the underlying bit array which are all set to <em>one</em>.</p><p><img src=bf-insert-test.png alt="Diagram demonstrating insertion and test operations on Bloom filters. Two values are inserted. One previously inserted value and a made up value are tested for membership. The former is accepted, while the latter is rejected."></p><p>Now if you want to test if an item has been inserted into a Bloom filter, you run it through the same <em>k</em> hash functions.
With the <em>k</em> hash values, you check the bits at the corresponding indices in the bit array, yielding one of the two aforementioned results.</p><ul><li>If <strong>all bits are set</strong>, then the item was likely inserted into the Bloom filter.</li><li>If <strong>at least one bit is unset</strong>, then the item has not been inserted into the Bloom filter.</li></ul><p>The reason why Bloom filters are prone to false positives becomes apparent here.
Assume you want to check whether an item has been inserted into a Bloom filter.
You get a positive result, but you cannot know for sure if the referenced bits were set by any other combination of items that have actually been previously inserted into the Bloom filter.
This false positive probability can be computed using <em>m</em>, <em>k</em> and the amount of inserted items, but it boils down to the following intuitive statements.</p><p>The probability of a false positive test result <strong>increases</strong> &mldr;</p><ul><li>&mldr; the <strong>fewer bits</strong> there are.</li><li>&mldr; the <strong>more hash functions</strong> there are.</li><li>&mldr; the <strong>more items</strong> have been inserted.</li></ul><h2 id=blake2d-sha-1024-whirlpoolmd-384-maybe>BLAKE2d-SHA-1024-WhirlpoolMD-384 maybe?</h2><p>When I first learned about Bloom filters, there was one thing that stumped me, and I think it is worth mentioning here.
I talked about the need for <em>k</em> different hash functions.
Try to name all hash functions you can think of (without cheating!), whether they&rsquo;re cryptographic or non-cryptographic.
How many can you name?
Does it make sense that <em>k</em> can be arbitrarily large?</p><p>Turns out it does!
Kirsch and Mitzenmacher<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> were the first ones to describe a sort of &ldquo;double hashing&rdquo; scheme.
Assume you run an item through two hash functions, yielding the two hash values <em>h_1</em> and <em>h_2</em>.
One can create a new &ldquo;uber&rdquo; hash function called <em>g</em> defined as <em>g(i)=h_1+i*h_2</em>, where <em>i</em> runs from <em>1</em> to <em>k</em>.
With two base hash values and a simple linear combination, you can generate an arbitrary amount of hash values using <em>g</em>.</p><p>But it gets even better, because you don&rsquo;t even need two hash functions to begin with.
Let&rsquo;s assume we&rsquo;re only using <em>SHA-256</em>.
<em>SHA-256</em> yields a 32-byte hash digest.
We can set <em>h_1</em> and <em>h_2</em> to be the 16 high- and low-order bytes respectively, splitting our hash digest into two separate hash values.
This is what all modern Bloom filter implementations do, and what hash functions like <em>MurmurHash3</em> are for and ruthlessly efficient at.</p><p>If all of this flew over your head and you&rsquo;re the type of person who prefers to look at a code snippet rather than lengthy explanations, fret not.
I cooked up some code in Python which implements a very, very rudimentary Bloom filter with <em>SHA-256</em> as the backing hash function.
It&rsquo;s not efficient and it&rsquo;s not meant to be, but feel free to try it out to strengthen your understanding of Bloom filters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> hashlib
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> struct
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>new_bf</span>(m: int) <span style=color:#f92672>-&gt;</span> list[int]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(m)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>compute_hash_values</span>(k: int, value: bytes) <span style=color:#f92672>-&gt;</span> list[int]:
</span></span><span style=display:flex><span>    value_hash <span style=color:#f92672>=</span> hashlib<span style=color:#f92672>.</span>sha256(value)<span style=color:#f92672>.</span>digest()   <span style=color:#75715e># hash the value with SHA256</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    h1 <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>unpack(<span style=color:#e6db74>&#34;Q&#34;</span>, value_hash[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>8</span>])[<span style=color:#ae81ff>0</span>]   <span style=color:#75715e># take the first 8 bytes and convert to 32-bit int</span>
</span></span><span style=display:flex><span>    h2 <span style=color:#f92672>=</span> struct<span style=color:#f92672>.</span>unpack(<span style=color:#e6db74>&#34;Q&#34;</span>, value_hash[<span style=color:#ae81ff>8</span>:<span style=color:#ae81ff>16</span>])[<span style=color:#ae81ff>0</span>]  <span style=color:#75715e># take the second 8 bytes and convert to 32-bit int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [h1 <span style=color:#f92672>+</span> (i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> h2 <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(k)]    <span style=color:#75715e># compute values with double hashing scheme</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert_into_bloom_filter</span>(bf: list[int], k: int, value: bytes):
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(bf)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> compute_hash_values(k, value):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> h <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:      <span style=color:#75715e># check if the hash value is negative</span>
</span></span><span style=display:flex><span>            h <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>h     <span style=color:#75715e># if so, simply invert it</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        bf[h <span style=color:#f92672>%</span> m] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># set the corresponding bit to 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_bloom_filter</span>(bf: list[int], k: int, value: bytes) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(bf)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> compute_hash_values(k, value):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> h <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:           <span style=color:#75715e># same trick as above</span>
</span></span><span style=display:flex><span>            h <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>h
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> bf[h <span style=color:#f92672>%</span> m] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># if any bit is not set, then we can be sure that the value has not been inserted</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>  <span style=color:#75715e># otherwise, all bits match, meaning that the value might be part of the bloom filter</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bf <span style=color:#f92672>=</span> new_bf(<span style=color:#ae81ff>64</span>)  <span style=color:#75715e># create a new 64-bit bloom filter</span>
</span></span><span style=display:flex><span>k <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>insert_into_bloom_filter(bf, k, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;foo&#34;</span>)  <span style=color:#75715e># insert &#34;foo&#34; into the bloom filter</span>
</span></span><span style=display:flex><span>insert_into_bloom_filter(bf, k, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;bar&#34;</span>)  <span style=color:#75715e># insert &#34;bar&#34; into the bloom filter</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(test_bloom_filter(bf, k, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;foo&#34;</span>))  <span style=color:#75715e># this will return True since we inserted &#34;foo&#34; into the bloom filter</span>
</span></span><span style=display:flex><span>print(test_bloom_filter(bf, k, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;baz&#34;</span>))  <span style=color:#75715e># this will *most likely* return False since not many bits are set yet</span>
</span></span></code></pre></div><p>Unnecessary details aside, let&rsquo;s finally bridge the gap to record linkage.</p><h2 id=filtering-matches--get-it>Filtering matches &mldr; get it?</h2><p><strong>Privacy-preserving record linkage</strong> (PPRL) based on Bloom filters falls into the category of probabilistic record linkage methods.
This means that given a pair of records, we compute their similarity, usually in the range of 0% to 100%.
If this similarity is above or below a certain threshold, we classify the record pair as a match or a non-match respectively.</p><blockquote><p>Just as an aside: deterministic record linkage &mdash; the other category of record linkage methods &mdash; works fundamentally different.
Given a record, we try to construct a so-called &ldquo;match key&rdquo; that&rsquo;s identical between similar records.
You can think of it as an attempt to generate a synthetic identifier based on attribute values of a record.</p></blockquote><p>So the idea is as follows: we generate a Bloom filter for every record.
Then we use the constructed Bloom filters to somehow assign a similarity to record pairs.
If we were to put an entire record into a Bloom filter, then we wouldn&rsquo;t have gained anything, since the bit patterns generated by similar record pairs would be fundamentally different.
This is why Schnell et al.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> were the first ones to describe a clever record linkage algorithm using Bloom filters.</p><p>Let&rsquo;s take &ldquo;John Doe&rdquo; as our example record.
It consists of two attributes, namely the first name &ldquo;John&rdquo; and the last name &ldquo;Doe&rdquo;.
First, we normalize these attribute by converting them into all caps, yielding &ldquo;JOHN&rdquo; and &ldquo;DOE&rdquo;.
Next, we split every attribute into text tokens of the same size.
These tokens are also called <strong>q-grams</strong>, where <em>q</em> represents the length of these tokens.
So if we split the attributes into 2-grams, also called bigrams, we&rsquo;re left with &ldquo;_J&rdquo;, &ldquo;JO&rdquo;, &ldquo;OH&rdquo;, &ldquo;HN&rdquo;, &ldquo;N_&rdquo; for the first name and &ldquo;_D&rdquo;, &ldquo;DO&rdquo;, &ldquo;OE&rdquo;, &ldquo;E_&rdquo; for the last name.
The underscores represent padding characters.
They&rsquo;re used to give the characters at the start and the end of an attribute value the same weight as every other character.
With a predetermined filter size <em>m</em> and amount of hash values <em>k</em>, we now create a new Bloom filter and insert every token generated by the record into it.
The resulting bit pattern inside the Bloom filter is also called <strong>cryptographic long-term key</strong> (CLK).</p><p><img src=bf-bigram-insert.png alt="Diagram demonstrating Bloom filter based privacy-preserving record linkage. A new Bloom filter is constructed. The record values &ldquo;John&rdquo; and &ldquo;Doe&rdquo; are converted into uppercase, split into text tokens of size two, and inserted into the Bloom filter, yielding a unique bit pattern called cryptographic long-term key."></p><p>When we repeat the same process for a similar record like &ldquo;John Due&rdquo;, we find that the resulting bit pattern will be similar to that of &ldquo;John Doe&rdquo;.
Because of the tokenization step, most tokens that are inserted into the Bloom filter will be equal, with the exception of the tokens generated by the typo in the last name.
This means that just by using Bloom filters, we get built-in error tolerance for free.</p><p>The similarity between two CLKs is then computed by looking at the overlapping set bits.
A similarity measure that is commonly used in Bloom filter based PPRL is the Sørensen-Dice coefficient.
Given a pair of CLKs, let <em>X</em> and <em>Y</em> be the amount of set bits in each CLK.
Let <em>U</em> be the amount of set bits in the intersection of both CLKs.
Technically speaking, you&rsquo;re counting the set bits after performing a bitwise AND with both CLKs.
The similarity is then computed as <em>2U/(X+Y)</em>.</p><p><img src=bf-dsc-compute.png alt="Diagram demonstrating insertion and test operations on Bloom filters. Two values are inserted. One previously inserted value and a made up value are tested for membership. The former is accepted, while the latter is rejected."></p><p>And now we are where we want to be!
All that&rsquo;s left to do is to select a threshold and to classify pairs of CLKs as matches and non-matches.</p><h2 id=whats-next>What&rsquo;s next?</h2><p>Let&rsquo;s go back to the list of problems I wrote up at the start of this post and see if we solved them all.</p><ol><li>We don&rsquo;t have to rely on universal identifiers. We can work on QIDs just fine.</li><li>When using cryptograhic hash functions, reconstructing personal data based on a bit pattern generated by a Bloom filter becomes infeasible.</li><li>Typographic and technical errors are accounted for by performing the normalization and tokenization steps before constructing the Bloom filter.</li></ol><p>Sounds good, right?
This means Bloom filters are the silver bullet to perform record linkage in a privacy-preserving matter.
Another problem solved forever!</p><p>Of course, it&rsquo;s not that simple.
I wouldn&rsquo;t dedicate a whole series of posts to this topic if that&rsquo;s all there&rsquo;s to it.
This post is simply a primer on Bloom filter based PPRL.
And I assume that people working in cybersecurity reading this post are rightfully skeptical about whether the solution to record linkage is truly this simple.</p><p>In the next instalment, I will cover some re-identification attacks on Bloom filters and showcase one particularly effective attack that is as simple as it is dangerous.
Because even though determining the data that generated a specific bit pattern sounds infeasible, it is by no means impossible.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The &ldquo;o&rdquo; in &ldquo;John Doe&rdquo; is the Cyrillic small letter &ldquo;о&rdquo;. This is a so-called homoglyph and the Unicode specification is full of them.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>See: Broder, Andrei, and Michael Mitzenmacher. &ldquo;Network applications of bloom filters: A survey.&rdquo; <em>Internet mathematics</em> 1.4 (2004): 485-509.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>See: Kirsch, Adam, and Michael Mitzenmacher. &ldquo;Less hashing, same performance: Building a better bloom filter.&rdquo; <em>European Symposium on Algorithms.</em> Springer, Berlin, Heidelberg, 2006.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>See: Schnell, Rainer, Tobias Bachteler, and Jörg Reiher. &ldquo;A novel error-tolerant anonymous linking code.&rdquo; <em>Available at SSRN 3549247</em> (2011)&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></main><footer class=page-footer><hr><nav class="nav nav-footer"><ul><li class=li-no-marker><a href=https://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></li><li><a href=https://eulenbu.de/impressum>Impressum</a></li></ul></nav></footer><div class=page-owl><div class=owl><input type=button class=owl-btn value="Pat the owl"><div class=owl-counter>&#9829; &#215; <span class=owl-counter-value>1,337</span></div></div></div></div><script src=https://eulenbu.de/js/background.js></script><script src=https://eulenbu.de/js/custom.js></script></body></html>